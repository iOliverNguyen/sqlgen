// Code generated by goderive DO NOT EDIT.

package test

import (
	"database/sql"
	"time"

	core "github.com/ng-vu/sqlgen/core"
	sq "github.com/ng-vu/sqlgen/typesafe/sq"
)

type (
	Array  = core.Array
	Bool   = core.Bool
	Float  = core.Float
	Int    = core.Int
	Int64  = core.Int64
	JSON   = core.JSON
	String = core.String
	Time   = core.Time
	IState = core.IState
)

var __zeroTime = time.Unix(0, 0)

// Type *User represents table "user"
func sqlgenUser(_ *User) bool { return true }

type Users []*User

const __sqlUser_Table = `user`
const __sqlUser_ListCols = `"id","name","created_at","updated_at","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUser_Insert = `INSERT INTO "user" (` + __sqlUser_ListCols + `) VALUES`
const __sqlUser_Select = `SELECT ` + __sqlUser_ListCols + ` FROM "user"`
const __sqlUser_UpdateAll = `UPDATE "user" SET (` + __sqlUser_ListCols + `)`

func (m *User) SQLTableName() string {
	return "user"
}

func (m Users) SQLTableName() string {
	return "user"
}

func (m *User) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		String(m.Name),
		Time(m.CreatedAt),
		m.UpdatedAt,
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *User) SQLSelect(b []byte) []byte {
	return append(b, __sqlUser_Select...)
}

func (_ *Users) SQLSelect(b []byte) []byte {
	return append(b, __sqlUser_Select...)
}

func (m *User) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 14)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms Users) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 14)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *User) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		(*String)(&m.Name),
		(*Time)(&m.CreatedAt),
		&m.UpdatedAt,
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *User) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *Users) SQLScan(rows *sql.Rows) error {
	res := make(Users, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(User)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *User) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if m.Name != "" {
		flag = true
		b = append(b, `"name"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Name)
	}
	if !m.CreatedAt.IsZero() && !m.CreatedAt.Equal(__zeroTime) {
		flag = true
		b = append(b, `"created_at"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		flag = true
		b = append(b, `"updated_at"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.UpdatedAt)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *User) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 14)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

// Type *UserSubset represents table "user"
func sqlgenUserSubset(_ *UserSubset, _ *User) bool { return true }

type UserSubsets []*UserSubset

// *UserSubset is a substruct of *User
func substructUserSubset(_ *UserSubset, _ *User) bool { return true }

func UserSubsetsFromUsers(ps []*User) []*UserSubset {
	ss := make([]*UserSubset, len(ps))
	for i, p := range ps {
		ss[i] = NewUserSubsetFromUser(p)
	}
	return ss
}

func UserSubsetsToUsers(ss []*UserSubset) []*User {
	ps := make([]*User, len(ss))
	for i, s := range ss {
		ps[i] = s.ToUser()
	}
	return ps
}

func NewUserSubsetFromUser(sp *User) *UserSubset {
	if sp == nil {
		return nil
	}
	s := new(UserSubset)
	s.CopyFrom(sp)
	return s
}

func (s *UserSubset) ToUser() *User {
	if s == nil {
		return nil
	}
	sp := new(User)
	s.AssignTo(sp)
	return sp
}

func (s *UserSubset) CopyFrom(sp *User) {
	s.ID = sp.ID
	s.Bool = sp.Bool
	s.Float64 = sp.Float64
	s.Int = sp.Int
	s.Int64 = sp.Int64
	s.String = sp.String
	s.PBool = sp.PBool
	s.PFloat64 = sp.PFloat64
	s.PInt = sp.PInt
	s.PInt64 = sp.PInt64
	s.PString = sp.PString
}

func (s *UserSubset) AssignTo(sp *User) {
	sp.ID = s.ID
	sp.Bool = s.Bool
	sp.Float64 = s.Float64
	sp.Int = s.Int
	sp.Int64 = s.Int64
	sp.String = s.String
	sp.PBool = s.PBool
	sp.PFloat64 = s.PFloat64
	sp.PInt = s.PInt
	sp.PInt64 = s.PInt64
	sp.PString = s.PString
}

const __sqlUserSubset_Table = `user`
const __sqlUserSubset_ListCols = `"id","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUserSubset_Insert = `INSERT INTO "user" (` + __sqlUserSubset_ListCols + `) VALUES`
const __sqlUserSubset_Select = `SELECT ` + __sqlUserSubset_ListCols + ` FROM "user"`
const __sqlUserSubset_UpdateAll = `UPDATE "user" SET (` + __sqlUserSubset_ListCols + `)`

func (m *UserSubset) SQLTableName() string {
	return "user"
}

func (m UserSubsets) SQLTableName() string {
	return "user"
}

func (m *UserSubset) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *UserSubset) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserSubset_Select...)
}

func (_ *UserSubsets) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserSubset_Select...)
}

func (m *UserSubset) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 11)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserSubsets) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 11)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserSubset) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *UserSubset) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserSubsets) SQLScan(rows *sql.Rows) error {
	res := make(UserSubsets, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserSubset)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserSubset) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserSubset) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 11)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

// Type *UserInfo represents table "user_info"
func sqlgenUserInfo(_ *UserInfo) bool { return true }

type UserInfoes []*UserInfo

const __sqlUserInfo_Table = `user_info`
const __sqlUserInfo_ListCols = `"user_id","metadata","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUserInfo_Insert = `INSERT INTO "user_info" (` + __sqlUserInfo_ListCols + `) VALUES`
const __sqlUserInfo_Select = `SELECT ` + __sqlUserInfo_ListCols + ` FROM "user_info"`
const __sqlUserInfo_UpdateAll = `UPDATE "user_info" SET (` + __sqlUserInfo_ListCols + `)`

func (m *UserInfo) SQLTableName() string {
	return "user_info"
}

func (m UserInfoes) SQLTableName() string {
	return "user_info"
}

func (m *UserInfo) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.UserID),
		String(m.Metadata),
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *UserInfo) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInfo_Select...)
}

func (_ *UserInfoes) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInfo_Select...)
}

func (m *UserInfo) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 12)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserInfoes) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 12)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserInfo) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.UserID),
		(*String)(&m.Metadata),
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *UserInfo) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserInfoes) SQLScan(rows *sql.Rows) error {
	res := make(UserInfoes, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserInfo)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserInfo) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_info" SET `...)
	if m.UserID != "" {
		flag = true
		b = append(b, `"user_id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.UserID)
	}
	if m.Metadata != "" {
		flag = true
		b = append(b, `"metadata"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Metadata)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserInfo) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 12)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

// Type *UserUnion represents a join
func sqlgenUserUnion(_ *UserUnion, _ *User, as sq.AS, t0 sq.JOIN_TYPE, _ *UserInfo, a0 sq.AS, c0 string) bool {
	__sqlUserUnion_JoinTypes = []sq.JOIN_TYPE{t0}
	__sqlUserUnion_As = as + "."
	__sqlUserUnion_JoinAs = []sq.AS{a0 + "."}
	__sqlUserUnion_JoinConds = []string{c0}
	__sqlUserUnion_Select = (*UserUnion)(nil).__sqlSelect(make([]byte, 0, 1024))
	__sqlUserUnion_Join = (*UserUnion)(nil).__sqlJoin(make([]byte, 0, 1024), __sqlUserUnion_JoinTypes)
	return true
}

type UserUnions []*UserUnion

var __sqlUserUnion_JoinTypes []sq.JOIN_TYPE
var __sqlUserUnion_As sq.AS
var __sqlUserUnion_JoinAs []sq.AS
var __sqlUserUnion_JoinConds []string
var __sqlUserUnion_Select, __sqlUserUnion_Join []byte

func (m *UserUnion) SQLTableName() string {
	return "user"
}

func (m UserUnions) SQLTableName() string {
	return "user"
}

func (m *UserUnion) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserUnions) SQLScan(rows *sql.Rows) error {
	res := make(UserUnions, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserUnion)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnion) SQLSelect(b []byte) []byte {
	b = append(b, __sqlUserUnion_Select...)
	b = append(b, ' ')
	return append(b, __sqlUserUnion_Join...)
}

func (m UserUnions) SQLSelect(b []byte) []byte {
	return (*UserUnion)(nil).SQLSelect(b)
}

func (m *UserUnion) SQLJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	if len(types) == 0 {
		return append(b, __sqlUserUnion_Join...)
	}
	return m.__sqlJoin(b, types)
}

func (m UserUnions) SQLJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	return (*UserUnion)(nil).SQLJoin(b, types)
}

func (m *UserUnion) __sqlSelect(b []byte) []byte {
	b = append(b, `SELECT `...)
	b = core.AppendCols(b, string(__sqlUserUnion_As), __sqlUser_ListCols)
	b = append(b, ',')
	b = core.AppendCols(b, string(__sqlUserUnion_JoinAs[0]), __sqlUserInfo_ListCols)
	return b
}

func (m *UserUnion) __sqlJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	if len(types) != 1 {
		panic("Expect 1 type to join")
	}
	b = append(b, `FROM "`...)
	b = append(b, __sqlUser_Table...)
	b = append(b, `" AS `...)
	b = append(b, __sqlUserUnion_As[:len(__sqlUserUnion_As)-1]...)
	b = append(b, ' ')
	b = append(b, types[0]...)
	b = append(b, ` JOIN "`...)
	b = append(b, __sqlUserInfo_Table...)
	b = append(b, `" AS `...)
	b = append(b, __sqlUserUnion_JoinAs[0][:len(__sqlUserUnion_JoinAs[0])-1]...)
	b = append(b, ` ON `...)
	b = append(b, __sqlUserUnion_JoinConds[0]...)
	return b
}

func (m *UserUnion) SQLScanArgs(args []interface{}) []interface{} {
	m.User = new(User)
	args = m.User.SQLScanArgs(args)
	m.UserInfo = new(UserInfo)
	args = m.UserInfo.SQLScanArgs(args)
	return args
}

// Type *UserUnionMore represents a join
func sqlgenUserUnionMore(_ *UserUnionMore, _ *User, as sq.AS, t0 sq.JOIN_TYPE, _ *UserInfo, a0 sq.AS, c0 string, t1 sq.JOIN_TYPE, _ *UserSubset, a1 sq.AS, c1 string) bool {
	__sqlUserUnionMore_JoinTypes = []sq.JOIN_TYPE{t0, t1}
	__sqlUserUnionMore_As = as + "."
	__sqlUserUnionMore_JoinAs = []sq.AS{a0 + ".", a1 + "."}
	__sqlUserUnionMore_JoinConds = []string{c0, c1}
	__sqlUserUnionMore_Select = (*UserUnionMore)(nil).__sqlSelect(make([]byte, 0, 1024))
	__sqlUserUnionMore_Join = (*UserUnionMore)(nil).__sqlJoin(make([]byte, 0, 1024), __sqlUserUnionMore_JoinTypes)
	return true
}

type UserUnionMores []*UserUnionMore

var __sqlUserUnionMore_JoinTypes []sq.JOIN_TYPE
var __sqlUserUnionMore_As sq.AS
var __sqlUserUnionMore_JoinAs []sq.AS
var __sqlUserUnionMore_JoinConds []string
var __sqlUserUnionMore_Select, __sqlUserUnionMore_Join []byte

func (m *UserUnionMore) SQLTableName() string {
	return "user"
}

func (m UserUnionMores) SQLTableName() string {
	return "user"
}

func (m *UserUnionMore) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserUnionMores) SQLScan(rows *sql.Rows) error {
	res := make(UserUnionMores, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserUnionMore)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnionMore) SQLSelect(b []byte) []byte {
	b = append(b, __sqlUserUnionMore_Select...)
	b = append(b, ' ')
	return append(b, __sqlUserUnionMore_Join...)
}

func (m UserUnionMores) SQLSelect(b []byte) []byte {
	return (*UserUnionMore)(nil).SQLSelect(b)
}

func (m *UserUnionMore) SQLJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	if len(types) == 0 {
		return append(b, __sqlUserUnionMore_Join...)
	}
	return m.__sqlJoin(b, types)
}

func (m UserUnionMores) SQLJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	return (*UserUnionMore)(nil).SQLJoin(b, types)
}

func (m *UserUnionMore) __sqlSelect(b []byte) []byte {
	b = append(b, `SELECT `...)
	b = core.AppendCols(b, string(__sqlUserUnionMore_As), __sqlUser_ListCols)
	b = append(b, ',')
	b = core.AppendCols(b, string(__sqlUserUnionMore_JoinAs[0]), __sqlUserInfo_ListCols)
	b = append(b, ',')
	b = core.AppendCols(b, string(__sqlUserUnionMore_JoinAs[1]), __sqlUserSubset_ListCols)
	return b
}

func (m *UserUnionMore) __sqlJoin(b []byte, types []sq.JOIN_TYPE) []byte {
	if len(types) != 2 {
		panic("Expect 2 types to join")
	}
	b = append(b, `FROM "`...)
	b = append(b, __sqlUser_Table...)
	b = append(b, `" AS `...)
	b = append(b, __sqlUserUnionMore_As[:len(__sqlUserUnionMore_As)-1]...)
	b = append(b, ' ')
	b = append(b, types[0]...)
	b = append(b, ` JOIN "`...)
	b = append(b, __sqlUserInfo_Table...)
	b = append(b, `" AS `...)
	b = append(b, __sqlUserUnionMore_JoinAs[0][:len(__sqlUserUnionMore_JoinAs[0])-1]...)
	b = append(b, ` ON `...)
	b = append(b, __sqlUserUnionMore_JoinConds[0]...)
	b = append(b, ' ')
	b = append(b, types[1]...)
	b = append(b, ` JOIN "`...)
	b = append(b, __sqlUserSubset_Table...)
	b = append(b, `" AS `...)
	b = append(b, __sqlUserUnionMore_JoinAs[1][:len(__sqlUserUnionMore_JoinAs[1])-1]...)
	b = append(b, ` ON `...)
	b = append(b, __sqlUserUnionMore_JoinConds[1]...)
	return b
}

func (m *UserUnionMore) SQLScanArgs(args []interface{}) []interface{} {
	m.User = new(User)
	args = m.User.SQLScanArgs(args)
	m.UserInfo = new(UserInfo)
	args = m.UserInfo.SQLScanArgs(args)
	m.UserSubset = new(UserSubset)
	args = m.UserSubset.SQLScanArgs(args)
	return args
}

// Type *ComplexInfo represents table "complex_info"
func sqlgenComplexInfo(_ *ComplexInfo) bool { return true }

type ComplexInfoes []*ComplexInfo

const __sqlComplexInfo_Table = `complex_info`
const __sqlComplexInfo_ListCols = `"id","address","p_address","metadata","ints","int64s","strings","times","times_p","alias_string","alias_int64","alias_int","alias_bool","alias_float64","alias_p_string","alias_p_int64","alias_p_int","alias_p_bool","alias_p_float64"`
const __sqlComplexInfo_Insert = `INSERT INTO "complex_info" (` + __sqlComplexInfo_ListCols + `) VALUES`
const __sqlComplexInfo_Select = `SELECT ` + __sqlComplexInfo_ListCols + ` FROM "complex_info"`
const __sqlComplexInfo_UpdateAll = `UPDATE "complex_info" SET (` + __sqlComplexInfo_ListCols + `)`

func (m *ComplexInfo) SQLTableName() string {
	return "complex_info"
}

func (m ComplexInfoes) SQLTableName() string {
	return "complex_info"
}

func (m *ComplexInfo) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		JSON{&m.Address},
		JSON{m.PAddress},
		JSON{m.Metadata},
		Array{m.Ints},
		Array{m.Int64s},
		Array{m.Strings},
		Array{m.Times},
		Array{m.TimesP},
		String(m.AliasString),
		Int64(m.AliasInt64),
		Int(m.AliasInt),
		Bool(m.AliasBool),
		Float(m.AliasFloat64),
		m.AliasPString,
		m.AliasPInt64,
		m.AliasPInt,
		m.AliasPBool,
		m.AliasPFloat64,
	)
}

func (_ *ComplexInfo) SQLSelect(b []byte) []byte {
	return append(b, __sqlComplexInfo_Select...)
}

func (_ *ComplexInfoes) SQLSelect(b []byte) []byte {
	return append(b, __sqlComplexInfo_Select...)
}

func (m *ComplexInfo) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 19)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms ComplexInfoes) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 19)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *ComplexInfo) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		JSON{&m.Address},
		JSON{&m.PAddress},
		JSON{&m.Metadata},
		Array{&m.Ints},
		Array{&m.Int64s},
		Array{&m.Strings},
		Array{&m.Times},
		Array{&m.TimesP},
		(*String)(&m.AliasString),
		(*Int64)(&m.AliasInt64),
		(*Int)(&m.AliasInt),
		(*Bool)(&m.AliasBool),
		(*Float)(&m.AliasFloat64),
		&m.AliasPString,
		&m.AliasPInt64,
		&m.AliasPInt,
		&m.AliasPBool,
		&m.AliasPFloat64,
	)
}

func (m *ComplexInfo) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *ComplexInfoes) SQLScan(rows *sql.Rows) error {
	res := make(ComplexInfoes, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(ComplexInfo)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *ComplexInfo) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "complex_info" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if true {
		flag = true
		b = append(b, `"address"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{&m.Address})
	}
	if m.PAddress != nil {
		flag = true
		b = append(b, `"p_address"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.PAddress})
	}
	if m.Metadata != nil {
		flag = true
		b = append(b, `"metadata"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.Metadata})
	}
	if m.Ints != nil {
		flag = true
		b = append(b, `"ints"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Ints})
	}
	if m.Int64s != nil {
		flag = true
		b = append(b, `"int64s"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Int64s})
	}
	if m.Strings != nil {
		flag = true
		b = append(b, `"strings"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Strings})
	}
	if m.Times != nil {
		flag = true
		b = append(b, `"times"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Times})
	}
	if m.TimesP != nil {
		flag = true
		b = append(b, `"times_p"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.TimesP})
	}
	if m.AliasString != "" {
		flag = true
		b = append(b, `"alias_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasString)
	}
	if m.AliasInt64 != 0 {
		flag = true
		b = append(b, `"alias_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasInt64)
	}
	if m.AliasInt != 0 {
		flag = true
		b = append(b, `"alias_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasInt)
	}
	if m.AliasBool {
		flag = true
		b = append(b, `"alias_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasBool)
	}
	if m.AliasFloat64 != 0 {
		flag = true
		b = append(b, `"alias_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasFloat64)
	}
	if m.AliasPString != nil {
		flag = true
		b = append(b, `"alias_p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPString)
	}
	if m.AliasPInt64 != nil {
		flag = true
		b = append(b, `"alias_p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPInt64)
	}
	if m.AliasPInt != nil {
		flag = true
		b = append(b, `"alias_p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPInt)
	}
	if m.AliasPBool != nil {
		flag = true
		b = append(b, `"alias_p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPBool)
	}
	if m.AliasPFloat64 != nil {
		flag = true
		b = append(b, `"alias_p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPFloat64)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *ComplexInfo) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 19)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

// Type *UserTag represents table "user_tag"
func sqlgenUserTag(_ *UserTag) bool { return true }

type UserTags []*UserTag

const __sqlUserTag_Table = `user_tag`
const __sqlUserTag_ListCols = `"province","new_name"`
const __sqlUserTag_Insert = `INSERT INTO "user_tag" (` + __sqlUserTag_ListCols + `) VALUES`
const __sqlUserTag_Select = `SELECT ` + __sqlUserTag_ListCols + ` FROM "user_tag"`
const __sqlUserTag_UpdateAll = `UPDATE "user_tag" SET (` + __sqlUserTag_ListCols + `)`

func (m *UserTag) SQLTableName() string {
	return "user_tag"
}

func (m UserTags) SQLTableName() string {
	return "user_tag"
}

func (m *UserTag) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.Inline.Province),
		String(m.Rename),
	)
}

func (_ *UserTag) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserTag_Select...)
}

func (_ *UserTags) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserTag_Select...)
}

func (m *UserTag) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserTags) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 2)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserTag) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.Inline.Province),
		(*String)(&m.Rename),
	)
}

func (m *UserTag) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserTags) SQLScan(rows *sql.Rows) error {
	res := make(UserTags, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserTag)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserTag) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_tag" SET `...)
	if m.Inline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Inline.Province)
	}
	if m.Rename != "" {
		flag = true
		b = append(b, `"new_name"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Rename)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserTag) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

// Type *UserInline represents table "user_inline"
func sqlgenUserInline(_ *UserInline) bool { return true }

type UserInlines []*UserInline

const __sqlUserInline_Table = `user_inline`
const __sqlUserInline_ListCols = `"province","province"`
const __sqlUserInline_Insert = `INSERT INTO "user_inline" (` + __sqlUserInline_ListCols + `) VALUES`
const __sqlUserInline_Select = `SELECT ` + __sqlUserInline_ListCols + ` FROM "user_inline"`
const __sqlUserInline_UpdateAll = `UPDATE "user_inline" SET (` + __sqlUserInline_ListCols + `)`

func (m *UserInline) SQLTableName() string {
	return "user_inline"
}

func (m UserInlines) SQLTableName() string {
	return "user_inline"
}

func (m *UserInline) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.Inline.Province),
		core.Ternary(m.PtrInline != nil, String(m.PtrInline.Province), nil),
	)
}

func (_ *UserInline) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInline_Select...)
}

func (_ *UserInlines) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInline_Select...)
}

func (m *UserInline) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserInlines) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 2)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserInline) SQLScanArgs(args []interface{}) []interface{} {
	m.PtrInline = new(Address)
	return append(args,
		(*String)(&m.Inline.Province),
		(*String)(&m.PtrInline.Province),
	)
}

func (m *UserInline) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserInlines) SQLScan(rows *sql.Rows) error {
	res := make(UserInlines, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserInline)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserInline) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_inline" SET `...)
	if m.Inline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Inline.Province)
	}
	if m.PtrInline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.PtrInline.Province)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserInline) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}
