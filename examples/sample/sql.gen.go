// Code generated by sqlgen DO NOT EDIT.

package test

import (
	"database/sql"
	time "time"

	core "github.com/ng-vu/sqlgen/core"
)

type (
	Array  = core.Array
	Bool   = core.Bool
	Float  = core.Float
	Int    = core.Int
	Int64  = core.Int64
	JSON   = core.JSON
	String = core.String
	Time   = core.Time
	IState = core.IState
)

var __zeroTime = time.Unix(0, 0)

type Users []*User

const __sqlUser_Table = `user`
const __sqlUser_ListCols = `"id","name","created_at","updated_at","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUser_Insert = `INSERT INTO "user" (` + __sqlUser_ListCols + `) VALUES`
const __sqlUser_Select = `SELECT ` + __sqlUser_ListCols + ` FROM "user"`
const __sqlUser_UpdateAll = `UPDATE "user" SET (` + __sqlUser_ListCols + `)`

func (m *User) SQLTableName() string {
	return "user"
}

func (m Users) SQLTableName() string {
	return "user"
}

func (m *User) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		String(m.Name),
		Time(m.CreatedAt),
		m.UpdatedAt,
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *User) SQLSelect(b []byte) []byte {
	return append(b, __sqlUser_Select...)
}

func (_ *Users) SQLSelect(b []byte) []byte {
	return append(b, __sqlUser_Select...)
}

func (m *User) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 14)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms Users) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 14)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *User) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		(*String)(&m.Name),
		(*Time)(&m.CreatedAt),
		&m.UpdatedAt,
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *User) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *Users) SQLScan(rows *sql.Rows) error {
	res := make(Users, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(User)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *User) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if m.Name != "" {
		flag = true
		b = append(b, `"name"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Name)
	}
	if !m.CreatedAt.IsZero() && !m.CreatedAt.Equal(__zeroTime) {
		flag = true
		b = append(b, `"created_at"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		flag = true
		b = append(b, `"updated_at"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.UpdatedAt)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *User) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUser_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 14)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserSubsets []*UserSubset

const __sqlUserSubset_Table = `user_subset`
const __sqlUserSubset_ListCols = `"id","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUserSubset_Insert = `INSERT INTO "user_subset" (` + __sqlUserSubset_ListCols + `) VALUES`
const __sqlUserSubset_Select = `SELECT ` + __sqlUserSubset_ListCols + ` FROM "user_subset"`
const __sqlUserSubset_UpdateAll = `UPDATE "user_subset" SET (` + __sqlUserSubset_ListCols + `)`

func (m *UserSubset) SQLTableName() string {
	return "user_subset"
}

func (m UserSubsets) SQLTableName() string {
	return "user_subset"
}

func (m *UserSubset) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *UserSubset) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserSubset_Select...)
}

func (_ *UserSubsets) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserSubset_Select...)
}

func (m *UserSubset) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 11)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserSubsets) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 11)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserSubset) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *UserSubset) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserSubsets) SQLScan(rows *sql.Rows) error {
	res := make(UserSubsets, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserSubset)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserSubset) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_subset" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserSubset) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserSubset_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 11)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserInfoes []*UserInfo

const __sqlUserInfo_Table = `user_info`
const __sqlUserInfo_ListCols = `"user_id","metadata","bool","float64","int","int64","string","p_bool","p_float64","p_int","p_int64","p_string"`
const __sqlUserInfo_Insert = `INSERT INTO "user_info" (` + __sqlUserInfo_ListCols + `) VALUES`
const __sqlUserInfo_Select = `SELECT ` + __sqlUserInfo_ListCols + ` FROM "user_info"`
const __sqlUserInfo_UpdateAll = `UPDATE "user_info" SET (` + __sqlUserInfo_ListCols + `)`

func (m *UserInfo) SQLTableName() string {
	return "user_info"
}

func (m UserInfoes) SQLTableName() string {
	return "user_info"
}

func (m *UserInfo) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.UserID),
		String(m.Metadata),
		Bool(m.Bool),
		Float(m.Float64),
		Int(m.Int),
		Int64(m.Int64),
		String(m.String),
		m.PBool,
		m.PFloat64,
		m.PInt,
		m.PInt64,
		m.PString,
	)
}

func (_ *UserInfo) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInfo_Select...)
}

func (_ *UserInfoes) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInfo_Select...)
}

func (m *UserInfo) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 12)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserInfoes) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 12)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserInfo) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.UserID),
		(*String)(&m.Metadata),
		(*Bool)(&m.Bool),
		(*Float)(&m.Float64),
		(*Int)(&m.Int),
		(*Int64)(&m.Int64),
		(*String)(&m.String),
		&m.PBool,
		&m.PFloat64,
		&m.PInt,
		&m.PInt64,
		&m.PString,
	)
}

func (m *UserInfo) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserInfoes) SQLScan(rows *sql.Rows) error {
	res := make(UserInfoes, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserInfo)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserInfo) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_info" SET `...)
	if m.UserID != "" {
		flag = true
		b = append(b, `"user_id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.UserID)
	}
	if m.Metadata != "" {
		flag = true
		b = append(b, `"metadata"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Metadata)
	}
	if m.Bool {
		flag = true
		b = append(b, `"bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Bool)
	}
	if m.Float64 != 0 {
		flag = true
		b = append(b, `"float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Float64)
	}
	if m.Int != 0 {
		flag = true
		b = append(b, `"int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int)
	}
	if m.Int64 != 0 {
		flag = true
		b = append(b, `"int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Int64)
	}
	if m.String != "" {
		flag = true
		b = append(b, `"string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.String)
	}
	if m.PBool != nil {
		flag = true
		b = append(b, `"p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PBool)
	}
	if m.PFloat64 != nil {
		flag = true
		b = append(b, `"p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PFloat64)
	}
	if m.PInt != nil {
		flag = true
		b = append(b, `"p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt)
	}
	if m.PInt64 != nil {
		flag = true
		b = append(b, `"p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PInt64)
	}
	if m.PString != nil {
		flag = true
		b = append(b, `"p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, *m.PString)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserInfo) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInfo_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 12)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserUnions []*UserUnion

const __sqlUserUnion_Table = `user_union`
const __sqlUserUnion_ListCols = `"user","user_info"`
const __sqlUserUnion_Insert = `INSERT INTO "user_union" (` + __sqlUserUnion_ListCols + `) VALUES`
const __sqlUserUnion_Select = `SELECT ` + __sqlUserUnion_ListCols + ` FROM "user_union"`
const __sqlUserUnion_UpdateAll = `UPDATE "user_union" SET (` + __sqlUserUnion_ListCols + `)`

func (m *UserUnion) SQLTableName() string {
	return "user_union"
}

func (m UserUnions) SQLTableName() string {
	return "user_union"
}

func (m *UserUnion) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		JSON{m.User},
		JSON{m.UserInfo},
	)
}

func (_ *UserUnion) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserUnion_Select...)
}

func (_ *UserUnions) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserUnion_Select...)
}

func (m *UserUnion) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnion_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserUnions) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnion_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 2)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserUnion) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		JSON{&m.User},
		JSON{&m.UserInfo},
	)
}

func (m *UserUnion) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserUnions) SQLScan(rows *sql.Rows) error {
	res := make(UserUnions, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserUnion)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnion) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_union" SET `...)
	if m.User != nil {
		flag = true
		b = append(b, `"user"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.User})
	}
	if m.UserInfo != nil {
		flag = true
		b = append(b, `"user_info"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.UserInfo})
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserUnion) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnion_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserUnionMores []*UserUnionMore

const __sqlUserUnionMore_Table = `user_union_more`
const __sqlUserUnionMore_ListCols = `"user","user_info","user_subset"`
const __sqlUserUnionMore_Insert = `INSERT INTO "user_union_more" (` + __sqlUserUnionMore_ListCols + `) VALUES`
const __sqlUserUnionMore_Select = `SELECT ` + __sqlUserUnionMore_ListCols + ` FROM "user_union_more"`
const __sqlUserUnionMore_UpdateAll = `UPDATE "user_union_more" SET (` + __sqlUserUnionMore_ListCols + `)`

func (m *UserUnionMore) SQLTableName() string {
	return "user_union_more"
}

func (m UserUnionMores) SQLTableName() string {
	return "user_union_more"
}

func (m *UserUnionMore) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		JSON{m.User},
		JSON{m.UserInfo},
		JSON{m.UserSubset},
	)
}

func (_ *UserUnionMore) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserUnionMore_Select...)
}

func (_ *UserUnionMores) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserUnionMore_Select...)
}

func (m *UserUnionMore) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnionMore_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 3)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserUnionMores) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnionMore_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 3)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserUnionMore) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		JSON{&m.User},
		JSON{&m.UserInfo},
		JSON{&m.UserSubset},
	)
}

func (m *UserUnionMore) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserUnionMores) SQLScan(rows *sql.Rows) error {
	res := make(UserUnionMores, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserUnionMore)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserUnionMore) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_union_more" SET `...)
	if m.User != nil {
		flag = true
		b = append(b, `"user"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.User})
	}
	if m.UserInfo != nil {
		flag = true
		b = append(b, `"user_info"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.UserInfo})
	}
	if m.UserSubset != nil {
		flag = true
		b = append(b, `"user_subset"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.UserSubset})
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserUnionMore) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserUnionMore_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 3)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type ComplexInfoes []*ComplexInfo

const __sqlComplexInfo_Table = `complex_info`
const __sqlComplexInfo_ListCols = `"id","address","p_address","metadata","ints","int64s","strings","times","times_p","alias_string","alias_int64","alias_int","alias_bool","alias_float64","alias_p_string","alias_p_int64","alias_p_int","alias_p_bool","alias_p_float64"`
const __sqlComplexInfo_Insert = `INSERT INTO "complex_info" (` + __sqlComplexInfo_ListCols + `) VALUES`
const __sqlComplexInfo_Select = `SELECT ` + __sqlComplexInfo_ListCols + ` FROM "complex_info"`
const __sqlComplexInfo_UpdateAll = `UPDATE "complex_info" SET (` + __sqlComplexInfo_ListCols + `)`

func (m *ComplexInfo) SQLTableName() string {
	return "complex_info"
}

func (m ComplexInfoes) SQLTableName() string {
	return "complex_info"
}

func (m *ComplexInfo) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.ID),
		JSON{&m.Address},
		JSON{m.PAddress},
		JSON{m.Metadata},
		Array{m.Ints},
		Array{m.Int64s},
		Array{m.Strings},
		Array{m.Times},
		Array{m.TimesP},
		String(m.AliasString),
		Int64(m.AliasInt64),
		Int(m.AliasInt),
		Bool(m.AliasBool),
		Float(m.AliasFloat64),
		m.AliasPString,
		m.AliasPInt64,
		m.AliasPInt,
		m.AliasPBool,
		m.AliasPFloat64,
	)
}

func (_ *ComplexInfo) SQLSelect(b []byte) []byte {
	return append(b, __sqlComplexInfo_Select...)
}

func (_ *ComplexInfoes) SQLSelect(b []byte) []byte {
	return append(b, __sqlComplexInfo_Select...)
}

func (m *ComplexInfo) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 19)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms ComplexInfoes) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 19)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *ComplexInfo) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.ID),
		JSON{&m.Address},
		JSON{&m.PAddress},
		JSON{&m.Metadata},
		Array{&m.Ints},
		Array{&m.Int64s},
		Array{&m.Strings},
		Array{&m.Times},
		Array{&m.TimesP},
		(*String)(&m.AliasString),
		(*Int64)(&m.AliasInt64),
		(*Int)(&m.AliasInt),
		(*Bool)(&m.AliasBool),
		(*Float)(&m.AliasFloat64),
		&m.AliasPString,
		&m.AliasPInt64,
		&m.AliasPInt,
		&m.AliasPBool,
		&m.AliasPFloat64,
	)
}

func (m *ComplexInfo) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *ComplexInfoes) SQLScan(rows *sql.Rows) error {
	res := make(ComplexInfoes, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(ComplexInfo)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *ComplexInfo) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "complex_info" SET `...)
	if m.ID != "" {
		flag = true
		b = append(b, `"id"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.ID)
	}
	if true {
		flag = true
		b = append(b, `"address"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{&m.Address})
	}
	if m.PAddress != nil {
		flag = true
		b = append(b, `"p_address"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.PAddress})
	}
	if m.Metadata != nil {
		flag = true
		b = append(b, `"metadata"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, JSON{m.Metadata})
	}
	if m.Ints != nil {
		flag = true
		b = append(b, `"ints"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Ints})
	}
	if m.Int64s != nil {
		flag = true
		b = append(b, `"int64s"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Int64s})
	}
	if m.Strings != nil {
		flag = true
		b = append(b, `"strings"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Strings})
	}
	if m.Times != nil {
		flag = true
		b = append(b, `"times"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.Times})
	}
	if m.TimesP != nil {
		flag = true
		b = append(b, `"times_p"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, Array{m.TimesP})
	}
	if m.AliasString != "" {
		flag = true
		b = append(b, `"alias_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasString)
	}
	if m.AliasInt64 != 0 {
		flag = true
		b = append(b, `"alias_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasInt64)
	}
	if m.AliasInt != 0 {
		flag = true
		b = append(b, `"alias_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasInt)
	}
	if m.AliasBool {
		flag = true
		b = append(b, `"alias_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasBool)
	}
	if m.AliasFloat64 != 0 {
		flag = true
		b = append(b, `"alias_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasFloat64)
	}
	if m.AliasPString != nil {
		flag = true
		b = append(b, `"alias_p_string"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPString)
	}
	if m.AliasPInt64 != nil {
		flag = true
		b = append(b, `"alias_p_int64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPInt64)
	}
	if m.AliasPInt != nil {
		flag = true
		b = append(b, `"alias_p_int"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPInt)
	}
	if m.AliasPBool != nil {
		flag = true
		b = append(b, `"alias_p_bool"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPBool)
	}
	if m.AliasPFloat64 != nil {
		flag = true
		b = append(b, `"alias_p_float64"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.AliasPFloat64)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *ComplexInfo) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlComplexInfo_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 19)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserTags []*UserTag

const __sqlUserTag_Table = `user_tag`
const __sqlUserTag_ListCols = `"province","new_name"`
const __sqlUserTag_Insert = `INSERT INTO "user_tag" (` + __sqlUserTag_ListCols + `) VALUES`
const __sqlUserTag_Select = `SELECT ` + __sqlUserTag_ListCols + ` FROM "user_tag"`
const __sqlUserTag_UpdateAll = `UPDATE "user_tag" SET (` + __sqlUserTag_ListCols + `)`

func (m *UserTag) SQLTableName() string {
	return "user_tag"
}

func (m UserTags) SQLTableName() string {
	return "user_tag"
}

func (m *UserTag) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.Inline.Province),
		String(m.Rename),
	)
}

func (_ *UserTag) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserTag_Select...)
}

func (_ *UserTags) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserTag_Select...)
}

func (m *UserTag) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserTags) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 2)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserTag) SQLScanArgs(args []interface{}) []interface{} {
	return append(args,
		(*String)(&m.Inline.Province),
		(*String)(&m.Rename),
	)
}

func (m *UserTag) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserTags) SQLScan(rows *sql.Rows) error {
	res := make(UserTags, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserTag)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserTag) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_tag" SET `...)
	if m.Inline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Inline.Province)
	}
	if m.Rename != "" {
		flag = true
		b = append(b, `"new_name"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Rename)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserTag) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserTag_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}

type UserInlines []*UserInline

const __sqlUserInline_Table = `user_inline`
const __sqlUserInline_ListCols = `"province","province"`
const __sqlUserInline_Insert = `INSERT INTO "user_inline" (` + __sqlUserInline_ListCols + `) VALUES`
const __sqlUserInline_Select = `SELECT ` + __sqlUserInline_ListCols + ` FROM "user_inline"`
const __sqlUserInline_UpdateAll = `UPDATE "user_inline" SET (` + __sqlUserInline_ListCols + `)`

func (m *UserInline) SQLTableName() string {
	return "user_inline"
}

func (m UserInlines) SQLTableName() string {
	return "user_inline"
}

func (m *UserInline) SQLArgs(args []interface{}, create bool) []interface{} {
	return append(args,
		String(m.Inline.Province),
		core.Ternary(m.PtrInline != nil, String(m.PtrInline.Province), nil),
	)
}

func (_ *UserInline) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInline_Select...)
}

func (_ *UserInlines) SQLSelect(b []byte) []byte {
	return append(b, __sqlUserInline_Select...)
}

func (m *UserInline) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_Insert...)
	b = append(b, ` (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, true), nil
}

func (ms UserInlines) SQLInsert(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_Insert...)
	b = append(b, ` (`...)
	for i := 0; i < len(ms); i++ {
		if i > 0 {
			b = append(b, `),(`...)
		}
		b = s.AppendMarker(b, 2)
		args = ms[i].SQLArgs(args, true)
	}
	b = append(b, ')')
	return b, args, nil
}

func (m *UserInline) SQLScanArgs(args []interface{}) []interface{} {
	m.PtrInline = new(Address)
	return append(args,
		(*String)(&m.Inline.Province),
		(*String)(&m.PtrInline.Province),
	)
}

func (m *UserInline) SQLScan(row *sql.Row) error {
	args := make([]interface{}, 0, 64)
	return row.Scan(m.SQLScanArgs(args)...)
}

func (ms *UserInlines) SQLScan(rows *sql.Rows) error {
	res := make(UserInlines, 0, 128)
	args := make([]interface{}, 0, 64)
	for rows.Next() {
		m := new(UserInline)
		args = args[:0]
		args = m.SQLScanArgs(args)
		if err := rows.Scan(args...); err != nil {
			return err
		}
		res = append(res, m)
	}
	if err := rows.Err(); err != nil {
		return err
	}
	*ms = res
	return nil
}

func (m *UserInline) SQLUpdate(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	var flag bool
	b = append(b, `UPDATE "user_inline" SET `...)
	if m.Inline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.Inline.Province)
	}
	if m.PtrInline.Province != "" {
		flag = true
		b = append(b, `"province"=`...)
		b = s.AppendMarker(b, 1)
		b = append(b, ',')
		args = append(args, m.PtrInline.Province)
	}
	if !flag {
		return nil, nil, core.ErrNoColumn
	}
	return b[:len(b)-1], args, nil
}

func (m *UserInline) SQLUpdateAll(s IState, b []byte, args []interface{}) ([]byte, []interface{}, error) {
	b = append(b, __sqlUserInline_UpdateAll...)
	b = append(b, ` = (`...)
	b = s.AppendMarker(b, 2)
	b = append(b, ')')
	return b, m.SQLArgs(args, false), nil
}
